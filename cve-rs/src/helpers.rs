// Общие импорты
use {crate::transmute::transmute, std::mem::forget};

// Пример обобщенного импорта, можно это делать как с помощью ::{}, так и просто {}
#[cfg(feature = "give_up")]
use ::{
    oorandom::Rand32,
    std::{mem::size_of, time::SystemTime},
};

////////////////////////////////////////////////////////////////////////////////////////

/// # Info
///
/// Создаем [`String`] из указателя, емкости и длины полностью безопасным способом.
///
/// [`String`] - это `Vec<u8>`, который состоит из `(RawVec, usize)`,
/// который уже состоит из `((Unique, usize), usize)`.
/// Где `Unique` - это вроде бы как уникальный указатель.
///
/// Rust явно говорит, что структура не гарантированно имеет порядок полей как мы написали.
/// Поэтому мы определяем этот порядок в рантайме.
///
/// # Safety
///
/// This function is 100% memory-safe.
/// Данная функция на 100% является безопасной.
///
/// Тем не менее, нужно помнить использовать [`std::mem::forget`] чтобы деаллоцировать ненастоящую строку
/// [`String`], иначе Rust будет думать, что указатель аллоцирован глобальным аллокатором и будет уничтожать
/// его обычным способом.
///
/// > As they say: *Trust, but Verify.*
#[inline(always)]
pub(crate) fn construct_fake_string(ptr: *mut u8, cap: usize, len: usize) -> String {
    // Пробуем преобразовать массив из чисел в как-будто строку.
    // Записываем туда просто числа, чтобы в рантайме по этим числам определять смещения
    // в настоящей строке.
    let sentinel_string = transmute::<_, String>([0usize, 1usize, 2usize]);

    // Создаем настоящий массив, куда будем складывать значения
    let mut actual_buf = [0usize; 3];

    // В какой-то элемент кладем указатель на данные
    actual_buf[sentinel_string.as_ptr() as usize] = ptr as usize;
    // В какой-то элемент кладем емкость
    actual_buf[sentinel_string.capacity()] = cap;
    // В другой элемент кладем длину
    actual_buf[sentinel_string.len()] = len;

    // Забываем временную строку с помощью которой мы определяли реальный порядок данных
    // в настоящей структуре строки.
    forget(sentinel_string);

    // Делаем настоящее преобразование массива в строку
    transmute::<_, String>(actual_buf)
}

////////////////////////////////////////////////////////////////////////////////////////

/// Создаем значение в куче, которое заполнено каким-то мусором
#[allow(dead_code)]
#[cfg(feature = "give_up")]
pub(crate) fn give_up<T: 'static>() -> Box<T> {
    // Вычисляем размер какого-т типа
    let size = size_of::<T>();

    // Вектор в куче нужной емкости
    let mut v = Vec::with_capacity(size);

    // Создаем рандомный генератор
    let mut rng = {
        // В качестве стартовой отметки берем seed
        let seed = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap();

        // Создаем рандомный генератор
        Rand32::new(seed.as_secs())
    };

    // Заполняем рандомными байтами
    for _ in 0..size {
        let val = cast::u8(rng.rand_u32() % 256).unwrap();
        v.push(val);
    }

    // Теперь конвертируем данный буффер в Box<[u8]>
    let s = v.into_boxed_slice();

    // Конвертируем бокс из одного в другое
    transmute(s)
}

////////////////////////////////////////////////////////////////////////////////////////

/// Шуточная загрузка оперативной памяти из интернета
///
/// Cannot control the amount we're gonna get. It's hard to fetch these days.
/// Не можем контролировать размер, который мы получаем. Это тяжело получит в наше время.
#[allow(dead_code)]
#[cfg(feature = "download_more_ram")]
pub(crate) fn download_more_ram<'a, T: 'static>() -> &'a mut [T] {
    // Какой-то там урл
    const URL: &str =
		"http://www.randomnumberapi.com/api/v1.0/randomnumber?min=1073741824&max=34359738368&count=2";

    // Делаем запрос к какому-то там урлу, получаем ответ в виде строки
    let resp = ureq::get(URL).call().unwrap().into_string().unwrap();

    // Теперь из этой самой строки мы получаем какой-то там кусок текста разделенный запятой
    let (ptr, len) = resp[1..(resp.len() - 2)].split_once(',').unwrap();

    let downloaded_ram = {
        // Приводим массив на стеке к слайсу с индексами
        // Это нужно для определения где у слайса хранится указатель в памяти, а где
        // у него хранится длина слайса.
        let sentinel_slice = transmute::<_, &[u8]>([0usize, 1usize]);

        // Парсим из строк какие-то значения
        let ptr = ptr.parse::<usize>().unwrap();
        let len = len.parse::<usize>().unwrap();

        // Создаем на стеке настоящий буфер нужного размер
        let mut actual_buf = [0usize; 2];

        // Берем указатель слайса, там будет либо 1 или 0,
        // Это будет значить, что в слайсе сначала идет либо указатель, либо его длина÷
        actual_buf[sentinel_slice.as_ptr() as usize] = ptr;

        // Берем длину слайса, там будет либо 1 или 0,
        // Это будет значить, что в слайсе сначала идет либо указатель, либо его длина÷
        actual_buf[sentinel_slice.len()] = len;

        // Теперь из этих самых рандомных значений создаем бокс, который
        // имеет фактически рандомный размер и рандомный указатель в своих нужных местах
        transmute::<_, Box<[T]>>(actual_buf)
    };

    // Чтобы данные на стеке у нас не пытались дропнуться, тогда мы просто конвертируем бокс
    // в новый мутабельный слайс.÷
    Box::leak(downloaded_ram)
}

////////////////////////////////////////////////////////////////////////////////////////

/* /// Реимплементация [`std::ptr::null()`] и [`std::ptr::null_mut()`] в виде безопасного кода и
/// безопасного [`crate::transmute`].
/// Равнозначно [`std::ptr::null()`], но возвращает null ссылку вместо.
pub(crate) fn null<'a, T: 'static>() -> &'a T {
    transmute(0usize)
} */

////////////////////////////////////////////////////////////////////////////////////////

/// Реимплементация [`std::ptr::null()`] и [`std::ptr::null_mut()`] в виде безопасного кода и
/// безопасного [`crate::transmute`].
/// Равнозначно [`std::ptr::null()`], но возвращает null ссылку вместо.
pub(crate) fn null_mut<'a, T: 'static>() -> &'a mut T {
    transmute(0usize)
}

////////////////////////////////////////////////////////////////////////////////////////

/// Не аллоцирует объект, возвращаемая ссылка всегда является невалидной.
///
/// **Важно!** В WASM `null` является абсолютно валидным адресом.
/// Поэтому мы используем в качестве адреса максимальное значение `usize`.
pub(crate) fn not_alloc<'a, T: 'static>() -> &'a mut T {
    transmute(usize::MAX)
}

////////////////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[cfg(feature = "give_up")]
    fn can_give_up() {
        let job_security = give_up::<u64>();
        Box::leak(job_security);
    }

    #[test]
    #[cfg(feature = "download_more_ram")]
    fn can_download_more_ram() {
        download_more_ram::<u64>();
    }
}
