//! So far, all our bugs are implemented using a single soundness hole in the Rust compiler.
//!
//! The explanation is detailed in the [`lifetime_expansion`] module.
//!
//! ---
//!
//! До тех пор, пока все наши баг реализованы используя одну единственную дыру в Rust компиляторе.
//!
//! Объяснение подробное есть в модуле [`lifetime_expansion`].
//!
//! https://github.com/rust-lang/rust/issues/25860
//!

#![deny(unsafe_code)]


////////////////////////////////////////////////////////////////////////////////////////

// The actual exploit
mod lifetime_expansion;
mod buffer_overflow;
mod references;
mod segfault;
mod transmute;
mod use_after_free;

////////////////////////////////////////////////////////////////////////////////////////

use self::{
	buffer_overflow::buffer_overflow,
	lifetime_expansion::*,
	references::{not_alloc, null, null_mut},
	segfault::segfault,
	transmute::transmute,
	use_after_free::use_after_free,
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

fn main() {
	// Парсим аргументы командной строки
	let mut args = std::env::args();

	// Пропускаем первый параметр с именем программы
	let _program = args.next();

	// Если конкретной команды нету, тогда выполняем вывод помощи
	let Some(subcommand) = args.next() else {
		println!("{HELP}");
		return;
	};

	// Выполняем нужную подкоманду
	match subcommand.as_str() {
		// Использование после деаллокации
		"uaf" => use_after_free(),
		// Сигфолт
		"segfault" => segfault(),
		// Переполнение буфера
		"bo" => buffer_overflow().unwrap(),
		// Transmute
		"transition" => transmute_demo().unwrap(),
		// Вы под различной помощи
		"help" | "--help" | "h" | "-h" | "?" | "-?" => println!("{HELP}"),
		// Не знаем что за команда
		other => println!("Error: Unknown command `{other}`.\n{HELP}"),
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

const HELP: &str = r"
cve-rs: Blazingly fast memory vulnerabilities, written in 100% safe rust.

This is a demo of the bugs implemented by cve-rs.

cve-rs exploits a soundness hole in lifetimes that lets us cast any lifetime to 'static, allowing us to create dangling references.
See: https://github.com/rust-lang/rust/issues/25860

This program is open-source! View the source for all these exploits here: https://github.com/Speykious/cve-rs

Commands:
    help        Show this help message.
    uaf         Run the use-after-free bug.
    bo          Run the buffer overflow exploit. Optionally take a shower.
    transition  Safely transmute a Boy to a Girl.
    segfault    Segfault yourself.
";

////////////////////////////////////////////////////////////////////////////////////////

/// Construct a [`String`] from a pointer, capacity and length, in a completely safe manner.
///
/// [`String`] is a `Vec<u8>` which is a `(RawVec, usize)` which is a `((Unique, usize), usize)`.
///
/// Rust explicitly says that structs are not guaranteed to have members in order,
/// so instead we determine that order at runtime.
///
/// # Safety
///
/// This function is 100% memory-safe.
///
/// Nevetheless, remember to use [`std::mem::forget`] to deallocate the fake [`String`], otherwise Rust
/// will think the pointer has been allocated by the global allocator and free it the wrong way.
///
/// > As they say: *Trust, but Verify.*
#[inline(always)]
pub fn construct_fake_string(ptr: *mut u8, cap: usize, len: usize) -> String {
	let sentinel_string = crate::transmute::<_, String>([0usize, 1usize, 2usize]);

	let mut actual_buf = [0usize; 3];
	actual_buf[sentinel_string.as_ptr() as usize] = ptr as usize;
	actual_buf[sentinel_string.capacity()] = cap;
	actual_buf[sentinel_string.len()] = len;

	std::mem::forget(sentinel_string);

	crate::transmute::<_, String>(actual_buf)
}

/// Good for job security.
#[cfg(feature = "give-up")]
pub fn give_up<T: 'static>() -> Box<T> {
	use std::time::SystemTime;

	let size = std::mem::size_of::<T>();

	let mut v = Vec::with_capacity(size);

	let mut rng = {
		let seed = SystemTime::now()
			.duration_since(SystemTime::UNIX_EPOCH)
			.unwrap();

		oorandom::Rand32::new(seed.as_secs())
	};

	for _ in 0..size {
		v.push((rng.rand_u32() % 256) as u8);
	}

	crate::transmute(v.into_boxed_slice())
}

/// Download more RAM from the internet.
///
/// Cannot control the amount we're gonna get. It's hard to fetch these days.
#[cfg(feature = "download-more-ram")]
pub fn download_more_ram<'a, T: 'static>() -> &'a mut [T] {
	const URL: &str =
		"http://www.randomnumberapi.com/api/v1.0/randomnumber?min=1073741824&max=34359738368&count=2";

	let resp = ureq::get(URL).call().unwrap().into_string().unwrap();

	let (ptr, len) = resp[1..(resp.len() - 2)].split_once(',').unwrap();

	let downloaded_ram = {
		let sentinel_slice = crate::transmute::<_, &[u8]>([0usize, 1usize]);

		let ptr = ptr.parse::<usize>().unwrap();
		let len = len.parse::<usize>().unwrap();

		let mut actual_buf = [0usize; 2];
		actual_buf[sentinel_slice.as_ptr() as usize] = ptr;
		actual_buf[sentinel_slice.len()] = len;

		crate::transmute::<_, Box<[T]>>(actual_buf)
	};

	Box::leak(downloaded_ram)
}

#[cfg(test)]
mod tests {
	#[test]
	#[cfg(feature = "give-up")]
	fn can_give_up() {
		let job_security = crate::give_up::<u64>();
		Box::leak(job_security);
	}

	#[test]
	#[cfg(feature = "download-more-ram")]
	fn can_download_more_ram() {
		crate::download_more_ram::<u64>();
	}
}
