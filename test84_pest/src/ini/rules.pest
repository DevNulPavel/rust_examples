// Сначала опишем просто символы обычные дотупные для идентификаторов
char = { ASCII_ALPHANUMERIC | "." | "_" | "/" }

// Так же опишем еще пробел дополнительно
// Вроде бы можно использовать SPACE_SEPARATOR?
// https://pest.rs/book/grammars/built-ins.html
// 
// Однако мы можем объявить специальный тип парсинга для пробела
// Если обозначить его с помощью "_" в самом начале, тогда эти самые символы не будут
// попадать в пары при парсинге
WHITESPACE = _{ " " }


// Имя не может быть пустым ни в коем случае
// Не совсем понятно для чего именно нужен символ "@"
// https://pest.rs/book/examples/ini.html#whitespace
key = @{ char+ }

// В то время как значение вполне может быть и пустым
value = @{ char* }

// Опишем грамматику для секции, пробелы у нас как могут быть, так и не быть
section = { "[" ~  WHITESPACE* ~ key ~ WHITESPACE* ~ "]" }

// Значение имеет такую грамматику, пробелы могут быть или не быть
property = { (key) ~ WHITESPACE* ~ "=" ~ WHITESPACE* ~ value }

// Создаем финальное правило для анализа всего файлика
// Символ ? означает, что у нас может быть либо 0, либо 1 раз встречаться правило
// Ищем построчно постепенно значения
file = {
    SOI ~ 
    ((section | property)? ~ NEWLINE)* ~
    EOI
}

// Строка может быть независимая от регистра c помощью символа ^: ^"text"

// Диапазон значений описывается следующим образом в одинарных кавычках так как это символ: '0'..'9'

// Существует ключевое слово ANY, которое обозначает вообще любой символ

// Правила могут идти в любом порядке, а так же быть рекурсивными:
//      my_rule = { "slithy " ~ other_rule }
//      other_rule = { "toves" }
//      recursive_rule = { "mimsy " ~ recursive_rule }

// Шаблоны в выражении могут быть как обернуты в скобки, так и нет - это равнозначно:
// ("abc") ~ (^"def" ~ ('g'..'z'))
// "abc" ~ (^"def" ~ 'g'..'z')

// Как и в регулярных выражениях, можно использовать указание конкретного количества элементов
// expr{n}    // Именно n раз
// expr{m, n} // Между m и n раз включительно
// expr{, n}  // Не более n повторений
// expr{m, }  // Как минимум m повторений

// Мы можем использовать символ & перед выражением, он значит, что предикат должен быть выполнен, тогда
// следующая часть будет выполнена с того же самого места
// Такую запись можно интерпретировать &foo ~ bar как текст должен соответствовать и foo, и bar правилу,
// но определится именно bar правило

// Можно использовать символ !, который значит, что можно обрабатывать только если правило не прошло
// Обработка будет продолжаться на том же месте, но при этом правило не будет как-то обработано.
// Иными словами - это просто выражение, которое не участвует в анализе, но является условием для правила.
//
// Если указанный текст не пробел и не табуляция, тогда читаем символ дальше
// not_space_or_tab = {
//     !(" " | "\t") ~ ANY
// }
//
// Если у нас не тройные кавычки, тогда просто принимаем символ дальше
// triple_quoted_character = { !"'''" ~ ANY }
// 
// Принимаем любые символы до тех пор пока не прилетият символы с тройными кавычками
// triple_quoted_string = { "'''" ~ triple_quoted_character* ~ "'''"}

// Операторы повтора имеют более высокий приоритет над операторами предиката
// my_rule = { "a"* ~ "b"? | &"b"+ ~ "a" }
// Таким образом это правило можно перефразировать вот так
// my_rule = { ( ("a"*) ~ ("b"?) ) | ( (&("b"+)) ~ "a" ) }

// Операторы SOI + EOI лишь показывают, что мы находимся в начале и в конце входной строки
// В первую очередь важен EOI, так как он показывает конец строки и что больше не будет ничего нового

// Правила, которые не должны попадать в парсинг, должны начинаться с "_"
// expression = {
//    "4" ~ (WHITESPACE | COMMENT)*
//    ~ "+" ~ (WHITESPACE | COMMENT)*
//    ~ "5"
// }
// WHITESPACE = _{ " " }
// COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
// "4+5"
// "4 + 5"
// "4  +     5"
// "4 /* comment */ + 5"

// Атомарные правила могу записываться вот так:
// atomic = @{ ... }            // Обычное атомарное правило
// compound_atomic = ${ ... }   // Составное атомарное правило
// Атомарные правила вроде как занимаются тем, что не позволяют неявным пробелам оказаться в тексте?
// В обычных атомиках внутренние правила silent, то есть не показываются в выводе.
// В составных внутренние правила показываются как и обычные.

// Грамматика имеет возможность сохранять выражения в стек