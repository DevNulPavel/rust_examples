
// Так же опишем еще пробел дополнительно
// Вроде бы можно использовать SPACE_SEPARATOR?
// https://pest.rs/book/grammars/built-ins.html
// 
// Однако мы можем объявить специальный тип парсинга для пробела
// Если обозначить его с помощью "_" в самом начале, тогда эти самые символы не будут
// попадать в пары при парсинге
WHITESPACE = _{ " " }

// Сначала опишем просто символы обычные дотупные для идентификаторов
char = { ASCII_ALPHANUMERIC | "." | "_" | "/" }

// Имя не может быть пустым ни в коем случае
// Не совсем понятно для чего именно нужен символ "@"
// https://pest.rs/book/examples/ini.html#whitespace
key = @{ char+ }

// В то время как значение вполне может быть и пустым
value = @{ char* }

// Опишем грамматику для секции, пробелы у нас как могут быть, так и не быть
// Но можно не указывать WHITESPACE, так как у нас мы автоматически определили WHITESPACE правило глобальное
section = { "[" ~  WHITESPACE* ~ key ~ WHITESPACE* ~ "]" }

// Значение имеет такую грамматику, пробелы могут быть или не быть
property = { (key) ~ WHITESPACE* ~ "=" ~ WHITESPACE* ~ value }

// Создаем финальное правило для анализа всего файлика
// Символ ? означает, что у нас может быть либо 0, либо 1 раз встречаться правило
// Ищем построчно постепенно значения
file = {
    SOI ~ 
    ((section | property)? ~ NEWLINE)* ~
    EOI
}

