// Описание грамматики:
// https://pest.rs/book/examples/json.html#writing-the-grammar

// Сначала определяем тихую грамматику для пробела и переноса строки, которая не будет попадать в 
// парсинг нашей строки.
// Если определены правила WHITESPACE или COMMENT, тогда они будут подставляться везде между продолжениями.
// Но кроме атомарнырных правил.
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }

//////////////////////////////////////////////////////////////////////////////////////////

// Составное атомарное правило значит, что при парсинге мы получаем подправила
// Начинается текст у нас с кавычек, заканчивается кавычками.
text = ${ "\"" ~ inner_text ~ "\"" }

// Внутренний текст уже атомарный, то есть там не может быть стандартных пробелов + правило silent и парсится уже как есть
inner_text = @{ char* }

// Символ в тексте
char = {
    // Если это не кавычка или не \, тогда получаем любые символы
    !("\"" | "\\") ~ ANY
    // Если у нас обратный слеш, тогда за ним должна идти либо кавычка, либо обратный слеш, либо просто слеш и тд
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    // Так же после слеша у нас может быть указание ASCII кода в виде четрых шестнадцатеричных чисел
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

// Правило делаем атомарным, то есть там не может встречаться пробел.
number = @{ 
    // В самом начале может быть, а может и не быть минус
    "-"? ~
    // Затем у нас может быть либо ноль, либо число, ноторое не начинается с нуля
    ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* ) ~
    // Затем может быть либо десятичная запятая с цифрами после, либо нет
    ("." ~ ASCII_DIGIT+)? ~
    // Затем может появиться экспоненциальная запись.
    // Сначала регистронезависимый символ "e", после этого может быть либо минус, либо нет.
    // Затем мы можем писать цифры минимум 1 раз.
    (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}

null = @{ "null" }

boolean = @{ "true" | "false" }

//////////////////////////////////////////////////////////////////////////////////////////

// Просто ключ опускаем так как на не нужны кавычки
key = _{ "\"" ~ key_inner ~ "\"" }

// Ключ с опущенными кавычками
key_inner = { (!"\"" ~ ANY)+ }

// Делаем правило silent так как оно является частью парсинга key_value???
value = _{ object | array | text | number | boolean | null }

key_value = { key ~ ":" ~ value }

array = {
    // Либо у нас просто пустой массив
    ("[" ~ "]") |
    // Либо у нас есть массив со значениями через запятую
    ("[" ~ value ~ ("," ~ value)* ~ "]")
}

object = {
    // Совсем пустой словарь отдельно
    ("{" ~ "}") | 
    // Словарь со значениями, разделенными запятыми
    ("{" ~ key_value ~ ("," ~ key_value)* ~ "}")
}

//////////////////////////////////////////////////////////////////////////////////////////

// Корневым у нас может быть либо массив, либо словарь.
file = _{ SOI ~ (array | object) ~ EOI }