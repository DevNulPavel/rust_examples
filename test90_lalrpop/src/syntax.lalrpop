// Сначала добавляем различный импорт из библиотек
use std::str::FromStr;

// Так начинается описание граматик?
grammar;

// Здесь в описании видно, что грамматика `Num` преобразуется в тип i32
Num: i32 = {
    // Грамматика представляет из себя регулярное выражение, которое начинается с
    // символа `r`, так же поддерживаются строки вида `r#..#` как и в обычном Rust.
    // Переменная `s` является леймблом для выражения, которое мы распарсили.
    //
    // Угловыми скобками обозначаются в lalrpop те куски кода, которые будут
    // каким-то образом вычисляться самим lalrpop.
    //
    // Затем после `=>` у нас уже идет код обработки строки.
    <s:r"[0-9]+"> => {
        // Здесь в коде мы уже преобразуем строку, которую распарсили в i32
        i32::from_str(s).unwrap()
    },
};

// Можно вообще не давать имена нашим лейблам, а просто использовать `<>`
// Num: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();

// Данная грамматика является публичной, тем самым lalrpop сгенерирует
// публичную структуру с названием `TermParser`.
// В отличние от закрытого типа `Num`.
// Результирующий тип данной грамматики является i32.
pub Term: i32 = {
    // Первый вариант - это просто число как есть
    <n:Num> => {
        n
    },
    // Другой вариант - рекурсивный, здесь то же правило обернуто в скобки.
    "(" <t:Term> ")" => {
        // Так как типы с Num совпадают внутренние, то можем возвращать как есть
        t
    },
};

// Сокращенный вариант запись для случаев, когда там не требуется выполнять никакие преобразования элементов
// pub Term: i32 = {
//     // Первый вариант - это просто число как есть
//     <n:Num>,
//     // Другой вариант - рекурсивный, здесь то же правило обернуто в скобки.
//     "(" <t:Term> ")"
// };
