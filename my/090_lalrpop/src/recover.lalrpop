use lalrpop_util::ErrorRecovery;
// Так можно испортировать просто какие-то модули
use std::str::FromStr;
// А так мы можем импортировать какие-то наши типы
use crate::recover::{Expr, Opcode};

/// Таким вот способом мы можем указать нестандартный способ парсинга,
/// добавляя туда поддержку продолжения в случае возникших ошибок.
/// Структура ErrorRecovery позволяет сохранить внутри пропущенные символы и их позиции.
/// У нас в процессе добавляется новый мутабельный тип, 
/// в который мы можем буфферизировать наши прилетающие ошибки в процессе парсинга.
grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, &'static str>>);

/// Описание нашего выражения, которое имеет тип Box<Expr> в самом Rust
pub(crate) Expr: Box<Expr> = {
    /// Здесь у нас аналогично калькулятору правило умножения имеет более высокий приоритет,
    /// так как оно является дочерним правилом.
    Expr ExprOp Factor => {
        // Мы можем заменить сразу три параметра, которые распарсились 
        // с помощью одного значения в угловых скобках `<>`
        Box::new(Expr::Op(<>))
    },
    /// Просто какое-то умножение
    Factor,
};

/// Операция сложения какая-то и вычитания
ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

/// Отдельно операция умножения для более высокого приоритета.
Factor: Box<Expr> = {
    /// Правило, где у нас есть другое выражение умножения сначала
    Factor FactorOp Term => {
        // Можно заменить сразу 3 выражения, которые распарсили
        // на значения, которые передаем в Op
        Box::new(Expr::Op(<>))
    },
    // Просто число или другое выражение в скобках
    Term,
};

/// Операции умножения и деления
FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

/// Какая-то операция с числом, которая обернута в Box из-за возможной рекурсивности
Term: Box<Expr> = {
    // Какое-то число
    Num => Box::new(Expr::Number(<>)),
    // Выражение в скобках
    "(" <Expr> ")" => <>,
    // Специальное отдельное правило для ошибок
    ! => { 
        // Здесь внутри мы можем сохранить ошибку
        // в мутабельный массив ошибок парсинга.
        errors.push(<>); 

        // Возвращать будем просто вариант выражения с ошибкой.
        Box::new(Expr::Error) 
    },
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};