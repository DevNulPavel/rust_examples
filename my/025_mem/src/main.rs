use std::mem;
use std::cell::RefCell;
use std::cell::RefMut;

fn main() {
    // Возвращает выравнивание адресов для конкретного типа данных, 
    // все адреса значений данного типа должны быть выровнены по данному адресу (не только в структурах?)
    {
        assert_eq!(4, mem::align_of::<i32>());
        assert_eq!(4, mem::align_of_val(&5i32));    
    }

    // Возвращает значение уникально идентифицирующее вариант энума параметра
    // Если переданное значение не энум, то вызов функции не приведет к UB, но результат не специфицирован
    // Может быть использован для сравнения перечислений, хранящих данные, без сравнения данных
    {
        enum Foo { 
            A(&'static str), 
            B(i32), 
            C(i32) 
        }
        assert_eq!(mem::discriminant(&Foo::A("bar")), mem::discriminant(&Foo::A("baz")));  // Одинаковый тип
        assert_eq!(mem::discriminant(&Foo::B(1)), mem::discriminant(&Foo::B(2)));          // Одинаковый тип 
        assert_ne!(mem::discriminant(&Foo::B(3)), mem::discriminant(&Foo::C(3)));          // Разный тип    
    }

    // Drop уничтожает значение, ничего не делает для типов, которые реализуют Copy, например - integer.
    // Такие значения сначала копируются и затем перемещаются в функцию. Поэтому значение остается доступным после вызова drop
    {
        // Создаем вектор
        let v = vec![1, 2, 3];
        drop(v); // Явно уничтожает вектор

        // Так как RefCell использует правила заимствования в рантайме, drop может сбросить заимствованное значение в рантайме
        let x: RefCell<i32> = RefCell::new(1i32);
        
        // Получаем изменяемую ссылку
        let mut mutable_borrow: RefMut<i32> = x.borrow_mut();
        // Изменяем значение
        *mutable_borrow = 1;
        
        // Освобождаем заимствованную изменяемую ссылку
        drop(mutable_borrow);
        
        // Теперь мы можем спокойно получить неизменяемую ссылку и паники не будет
        let borrow = x.borrow();
        println!("{}", *borrow);
        
        // Доббавляем автоматическую реализацию копирования структуре, 
        // теперь значение будет не перемещаться, а копироваться по-умолчанию
        //#[derive(Copy, Clone)]
        struct Foo(u8);

        // Просто описываем пустой трейт, чтобы сказать, что можем копировать
        // Однако копирование побитное!!!
        // Тим может реализовать копирование только если все его компоненты реализуют копирование
        impl Copy for Foo {
        }

        // Клонирование использует возможности копирования
        impl Clone for Foo {
            fn clone(&self) -> Foo {
                // Для клонировани нужно иметь возможность правильного копирования объекта
                *self
            }
        }

        let x = 1;
        let y = Foo(2);
        drop(x); // Не имеет смысла, это копия x перемещается и уничтожается
        drop(y); // Не имеет смысла, это копия y перемещается и уничтожается

        println!("x: {}, y: {}", x, y.0); // still available
    }

    {
        // forget позволяет забыть об объекте и не вызывать для него деструктор,
        // это полезно при работе с FFI
        let file = std::fs::File::open("foo.txt").unwrap();
        mem::forget(file);
    }

    {
        let mut v: Vec<i32> = vec![1, 2];

        // Перемещает второе значение на место первого, возвращая при этом значение старого
        let old_v = mem::replace(&mut v, vec![3, 4, 5]);
        assert_eq!(vec![1, 2], old_v);
        assert_eq!(vec![3, 4, 5], v);
    }
}
