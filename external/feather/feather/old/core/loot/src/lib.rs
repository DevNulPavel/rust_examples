//! Implements sampling of loot tables.

use ahash::AHashMap;
use feather_items::{Item, ItemStack};
use feather_loot_model as model;
use inlinable_string::InlinableString;
use itertools::Itertools;
use model::{Condition, Entry, EntryKind, Function, FunctionKind, LootTableSet, Pool};
use once_cell::sync::Lazy;
use rand::Rng;
use smallvec::SmallVec;
use std::iter;
use thiserror::Error;

/// The global loot table store, initialized at runtime from
/// the embedded loot table dump. (Generated by the build script)
static STORE: Lazy<AHashMap<InlinableString, LootTable>> = Lazy::new(|| {
    static BYTES: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/dump.json"));

    serde_json::from_slice::<LootTableSet>(BYTES)
        .expect("invalid loot table dump")
        .0
        .into_iter()
        .map(|(k, v)| (k, LootTable(v)))
        .collect()
});

/// Returns the loot table with the given ID, if it exists.
/// IDs are the same as those used in MC data packs. For example,
/// the loot table for stone blocks has ID "blocks/stone."
pub fn loot_table(id: &str) -> Option<&'static LootTable> {
    STORE.get(id)
}

/// Condition context used to determine whether loot table conditions are satisfied.
#[derive(Debug, Default)]
pub struct Conditions {
    /// The item used to break a block
    pub item: Option<ItemStack>,
}

/// Opaque wrapper over `model::LootTable`.
#[derive(Debug)]
pub struct LootTable(model::LootTable);

/// Error returned when a loot table sample fails.
#[derive(Debug, Error)]
pub enum SampleError {
    #[error("invalid item identifier {0}")]
    InvalidItem(String),
    #[error("missing loot table {0}")]
    MissingLootTable(String),
    /// Should be handled gracefully.
    #[error("dynamic loot table {0:?}")]
    IsDynamic(DynamicKind),
}

/// Indicates that the yielded item should
/// be computed based on a block entity.
#[derive(Debug)]
pub enum DynamicKind {
    /// Drop e.g. contents of chest
    Contents,
    /// Drop the block itself (e.g. player head, banner)
    This,
}

impl LootTable {
    /// Samples a value from the table.
    ///
    /// The returned set of item stacks is the result of sampling,
    /// i.e. the loot which should be yielded. May return multiple
    /// item stacks. No guarantee is made about the ordering
    /// or distinction of the returned vector.
    pub fn sample(
        &self,
        rng: &mut impl Rng,
        conditions: &Conditions,
    ) -> Result<SmallVec<[ItemStack; 2]>, SampleError> {
        let mut results = SmallVec::new();
        let pools = &self.0.pools;

        // Algorithm: sample each pool.
        // For each pool, evaluate `rolls` entries based on `Entry.weight`
        // and yield their results.
        for pool in pools {
            sample_pool(pool, rng, &mut results, conditions)?;
        }

        Ok(results)
    }
}

fn sample_pool(
    pool: &Pool,
    rng: &mut impl Rng,
    results: &mut SmallVec<[ItemStack; 2]>,
    conditions: &Conditions,
) -> Result<(), SampleError> {
    // `rolls` times, choose an entry at random based on weighting
    // and yield its results.

    // Only select from entries with their conditions satisfied
    let entries = pool
        .entries
        .iter()
        .filter(|entry| satisfies_conditions(entry.conditions.iter(), conditions, rng))
        .collect::<SmallVec<[&Entry; 4]>>();

    let weight_sum = entries.iter().map(|entry| entry.weight).sum::<u32>();
    for _ in 0..pool.rolls.sample(rng) {
        // We choose an integer at random from [0, weight_sum) and
        // determine which entry has a cumulative weight matching
        // the result. This algorithm is O(n) computaitonally, but this is unlikely
        // to matter in practice, because loot tables rarely
        // have more than one or two entries per pool.

        let n = rng.gen_range(0, weight_sum);
        let mut cumulative_weight = 0;
        let entry = entries
            .iter()
            .find(|entry| {
                if n >= cumulative_weight && n < cumulative_weight + entry.weight {
                    true
                } else {
                    cumulative_weight += entry.weight;
                    false
                }
            })
            .expect("entry finding algorithm incorrect");

        sample_entry(entry, rng, results, conditions)?;
    }

    // apply functions to results
    results
        .iter_mut()
        .try_for_each(|item| apply_functions(pool.functions.iter(), item, rng, conditions))?;

    Ok(())
}

fn sample_entry(
    entry: &Entry,
    rng: &mut impl Rng,
    results: &mut SmallVec<[ItemStack; 2]>,
    conditions: &Conditions,
) -> Result<(), SampleError> {
    let mut single;
    let mut none = iter::empty();
    let mut sampled;

    let items: &mut dyn Iterator<Item = ItemStack> = match &entry.kind {
        EntryKind::Empty => &mut none,
        EntryKind::Item => {
            let item = Item::from_identifier(&entry.name)
                .ok_or_else(|| SampleError::InvalidItem(entry.name.to_string()))?;

            single = iter::once(ItemStack::new(item, 1));
            &mut single
        }
        EntryKind::Tag => &mut none, // TODO
        EntryKind::LootTable => {
            let table = loot_table(&entry.name)
                .ok_or_else(|| SampleError::MissingLootTable(entry.name.to_string()))?;

            sampled = table.sample(rng, conditions)?.into_iter();
            &mut sampled
        }
        EntryKind::Group => {
            // Return an iterator over the child entries
            let mut temp = SmallVec::new();
            let entries = entry
                .children
                .iter()
                .filter(|entry| satisfies_conditions(entry.conditions.iter(), conditions, rng))
                .collect::<SmallVec<[&Entry; 4]>>();
            entries
                .into_iter()
                .try_for_each(|entry| sample_entry(entry, rng, &mut temp, conditions))?;
            sampled = temp.into_iter();
            &mut sampled
        }
        EntryKind::Alternatives => {
            // Only sample first entry whose conditions are satisfied, if any
            let mut temp = SmallVec::new();
            if let Some(entry) = entry
                .children
                .iter()
                .find(|entry| satisfies_conditions(entry.conditions.iter(), conditions, rng))
            {
                sample_entry(entry, rng, &mut temp, conditions)?;
            }
            sampled = temp.into_iter();
            &mut sampled
        }
        EntryKind::Sequence => {
            // Apply all entries until one does not satisfy conditions
            let mut temp = SmallVec::new();
            let entries = entry
                .children
                .iter()
                .map(|entry| {
                    if satisfies_conditions(entry.conditions.iter(), conditions, rng) {
                        Some(entry)
                    } else {
                        None
                    }
                })
                .while_some()
                .collect::<SmallVec<[&Entry; 4]>>();
            entries
                .into_iter()
                .try_for_each(|entry| sample_entry(entry, rng, &mut temp, conditions))?;
            sampled = temp.into_iter();
            &mut sampled
        }
        EntryKind::Dynamic => {
            let kind = if entry.name == "contents" || entry.name == "minecraft:contents" {
                DynamicKind::Contents
            } else {
                DynamicKind::This
            };

            return Err(SampleError::IsDynamic(kind));
        }
    };

    results.extend(
        items
            .map(|mut item| {
                apply_functions(entry.functions.iter(), &mut item, rng, conditions)?;
                Ok(item)
            })
            .filter_map(|item: Result<ItemStack, SampleError>| item.ok()),
    );

    Ok(())
}

fn apply_functions<'a>(
    functions: impl Iterator<Item = &'a Function>,
    item: &mut ItemStack,
    rng: &mut impl Rng,
    conditions: &Conditions,
) -> Result<(), SampleError> {
    let functions = functions
        .filter(|f| satisfies_conditions(f.conditions.iter(), conditions, rng))
        .collect::<SmallVec<[&Function; 4]>>();
    for function in functions {
        match &function.kind {
            FunctionKind::SetCount { count } => {
                let count = count.sample(rng);
                item.amount = count as u8;
            }
            FunctionKind::Unknown => (),
        }
    }

    Ok(())
}

fn satisfies_conditions<'a>(
    mut conditions: impl Iterator<Item = &'a Condition>,
    input: &Conditions,
    rng: &mut impl Rng,
) -> bool {
    conditions.all(|condition| match condition {
        Condition::MatchTool { predicate } => {
            if let Some(item) = &predicate.item {
                match &input.item {
                    Some(stack) => {
                        if stack.ty.identifier() != item {
                            return false;
                        }
                    }
                    None => return false,
                }
            }

            // enchantments are not yet supported
            if !predicate.enchantments.is_empty() {
                return false;
            }

            true
        }
        Condition::RandomChance { chance } => {
            let chance = chance.max(0.0).min(1.0);
            rng.gen_bool(chance)
        }
        Condition::Unknown => true,
    })
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::rngs::mock::StepRng;

    #[test]
    fn store_deserializes_successfully() {
        Lazy::force(&STORE);
    }

    #[test]
    fn sample_dirt() {
        let table = loot_table("blocks/dirt").expect("missing loot table for dirt block");

        let mut rng = StepRng::new(0, 1);

        let items = table.sample(&mut rng, &Conditions::default()).unwrap();

        assert_eq!(items.as_slice(), &[ItemStack::new(Item::Dirt, 1)]);
    }

    #[test]
    fn grass_block_condition() {
        let table = loot_table("blocks/grass_block").unwrap_or_else(|| {
            panic!(
                "missing loot table for grass block\nnote: loaded keys: {:?}",
                STORE.keys()
            );
        });

        let mut rng = StepRng::new(0, 1);

        let items = table.sample(&mut rng, &Conditions { item: None }).unwrap();

        assert_eq!(items.as_slice(), &[ItemStack::new(Item::Dirt, 1)]);
    }
}
